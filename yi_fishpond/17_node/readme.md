# node

## Webpack 中用到 Node 的 10 个核心基础能力

1. Javascript 语言基础

Node 所支持的 Javascript 语法特性的使用，是搭建 Webpack 最核心的语言基础。在 Node 里面对于 Javascript(ECMA) 的支持程度以及它主要语法特性的使用，在 Webpack 里面，Promise/Class/Arrow Function/Set/Symbol 等等这些现代的 JS 语法特性也是大规模的使用。

2. Node 的模块/包管理加载机制

服务端 JS 的模块规范使用CommonJS 的模块包关系来处理组织。

3. Node 的生态能力 - NPM

Webpack 的主仓库包括它的实际配置场景中，还依赖许许多多的三方 Plugins 和 Loaders，这些三方的模块也会有他们自己的依赖，所有这些依赖会形成一颗深度嵌套的依赖树。这时候就需要用到 Node 包管理工具 - NPM 下载指定模块到当前项目中放到 node_modules 目录下配置使用，那么 NPM 对于 Node 是怎么样的一个存在。

4. Node 的工具集 - path/url/util/zlib

在这些 node_modules 里面，随便点开一些代码，就能发现满屏的 util 和 path 的使用，这些常用的工具套件就像 Node 的贴心小助手，从琐碎杂烦的任务中解脱出来，无论是模块的代码结构，还是功能实现的便携程度，都有很大的提升。

5. Node 的文件操作能力 - fs

无论多么松散耦合的 JS 代码，Webpack 都能把它里面不同类型的文件抽离出来，最终经过一系列处理放到某个目标目录下，在这个过程中，就用到了 Node 非常重要的一个能力，就是文件操作能力。
Node 的 fs 能力作为底层，最终在 webpack 里面，作为插件来支持文件的生成，跨目录的复制转移等等这些骚操作。
文件的操作能力，也就是本地文件资源的交互与操作能力，在 Node 里面是 需要掌握的又一个核心能力，包括 Path 路径这些周边 API 的配套使用。

6. Node 的缓冲与流

日常使用 Webpack， 动辄会有几分钟的构建等待时间，这里面有大量的文件读写操作，需要有比较好的机制来保证数据操作效率，基于上面第 5 点的 Webpack 文件操作能力，在源码中其实就能看到大量的 stream 读写的封装了

7. Node 的事件机制 - EventEmitter

处理流的过程中，有 once('error|close') 这样的错误或者流结束这样的事件监听，来挂载对应的回调函数，怎样流的中转过程可以捕获到这样的触发事件呢

8. Node 的 HTTP 处理 - 请求与响应

ebpack 在本地起 dev 环境开发的时候，经常需要用到 Server 来代理静态资源，包括做接口转发，Webpack 插件用到的是 Express， 基本是插件配置好，就开箱即用，如果想要定制改造，那么不可避免的还是要理解 Node 里面的 HTTP 整套流程。

9. Node 的事件循环 - Event Loop

Webpack 的整个打包构建流里面，有着很多在执行的任务，这些任务有的是异步的有的是同步的，比如 webpack-master/lib/Compilation.js 里面等待构建结束时候检查是否有回调队列，如果没有就会定义一个新的 callback 动作去执行

10. Node 的进程集群 - Cluster

基于上面的 HTTP， 只要摸到服务端，就需要对所谓单线程事件驱动的高并发 Node IO 模型，能从自己嘴中讲出个所以然来，也要了解它的优劣势，那么如果再放大下场景， 来对 Node 服务进行横向扩展，让它可以支持更多的并发，更好的利用 CPU

## Node 的启动过程与模块生效时机

把 Node 分为了 3 层：

+ 第一层是对外暴露的 API，比如 fs/buffer/net 等，直接 require 进来用
+ 第二层可以看做是桥接层，一头连 JS，一头连 C++，让两个编程语言之间互相调用，比如 Node 项目中针对底层模块所封装的各种 bindings，或者 可以直接从外部来引入 C++ 模块作为插件使用，通过 JS 直接调用第三方 C++ 模块
+ 最后一层，就是 Node 整个底层所依赖的一坨 C/C++ 库，包括提供 JS 解释与运行的 v8 引擎，提供 crypto 加密算法的 openssl 等等。

Node 的运行是按照一定的顺序，来分别把 v8 启动，libuv 初始化，再把 v8 实例创建，Context 准备好，最后把模块代码导进来，最后把 libuv 跑起来，按照一定策略执行模块代码里的任务，直到任务跑完。

Node 世界，一切（独立 JS 文件）皆模块，模块之间互相隔离互不影响，通过引用来互相调用。