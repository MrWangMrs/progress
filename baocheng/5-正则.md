# 正则学习

## 基础知识点
### 1. 特殊元字符
    \d：[0-9]，表示一位数字，记忆方式 digit
    \D：[^0-9]，表示一位非数字
    \s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character
    \S：[^\t\v\n\r\f]，表示非空白符
    \w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word
    \W：[^0-9a-zA-Z]，表示非单词字符

### 2.基本元字符

    . ： 匹配除了换行符之外的任何单个字符
    \ ： 将下一个字符标记为特殊字符，例如， 'n' 匹配字符 'n'。'\n' 匹配         换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
    | ： 逻辑或操作符
    [ ] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像.，\这些字符都表示其本身
    - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面

### 3.数量元字符

    {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次
    + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次
    * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有
    ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1) 或者没有(1)，如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"。

### 4.位置元字符
    ^ ： 单独使用匹配表达式的开始
    \$ ： 匹配表达式的结束
    \b：匹配单词边界
    \B：匹配非单词边界
    (?=p)：匹配 p 前面的位置
    (?!p)：匹配不是 p 前面的位置

 ### 5.特殊元字符

    \d：[0-9]，表示一位数字，记忆方式 digit
    \D：[^0-9]，表示一位非数字
    \s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character
    \S：[^\t\v\n\r\f]，表示非空白符
    \w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word
    \W：[^0-9a-zA-Z]，表示非单词字符

### 6.标志字符
    g : 全局搜索 记忆方式global
    i ：不区分大小写 记忆方式 ignore
    m ：多行搜索

## 使用方法
### 1.创建正则对象
   - 正则表达式字面量  const regex = /ab+c/;
   - 调用RegExp对象的构造函数  const regex = new RegExp("ab+c");
### 2.正则表达式常用方法
    exec:	一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。
    test:	一个在字符串中测试是否匹配的RegExp方法，它返回true或false。
    match:	一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。
    search:	一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
    replace:	一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
    split:	一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。

### 3.正则匹配方式
#### 匹配多种数量
    用{m,n}来匹配多种数量，其他几种形式(+*?)都可以等价成这种
    var regex = /ab{2,5}c/g;
    var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
    console.log( string.match(regex) ); // ["abbc", "abbbc", "abbbbc", "abbbbbc"]

#### 贪婪和非贪婪
    默认贪婪
    var regex = /\d{2,5}/g;
    var string = "123 1234 12345 123456";
    console.log( string.match(regex) ); // ["123", "1234", "12345", "12345"]

    非贪婪（如果？紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符））
    var regex = /\d{2,5}?/g;
    var string = "123 1234 12345 123456";
    console.log( string.match(regex) ); // ["12", "12", "34", "12", "34", "12", "34", "56"]

#### 匹配多种情况
    用字符组[]来匹配多种情况，其他几种形式(\d\D\s\S\w\W)都可以等价成这种。比如
    var regex = /a[123]b/g;
    var string = "a0b a1b a2b a3b a4b";
    console.log( string.match(regex) ); // ["a1b", "a2b", "a3b"]

    如果字符组里面字符特别多的话可以用-来表示范围，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]，用[^0-9]表示非除了数字以外的字符

    多种情况也可以是多种分支,用管道符来连接|，比如  
    var regex = /good|goodbye/g;
    var string = "goodbye";
    console.log( string.match(regex) ); // ["good"]
    分支结构是惰性的，匹配到了就不再往后尝试了。



   
    