# 前言
js具有自动垃圾收集机制，所以我们在平时编程的时候并不需要太过于关心这方面的问题。但是多了解一些也是有好处的

# 原理
原理其实非常的简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作

# 方式
+ 标记清除
js中最常用的垃圾收集方式就是**标记清除**。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”

+ 引用计数
另一种不太常见的垃圾收集策略叫做**引用计数**。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数减1。**但是**，引用计数存在一个问题，就是当出现循环引用时，会出现无法回收的问题
    ```js
    function problem() {
        var objectA = new Object();
        var objectB = new Object();

        objectA.someOtherObject = objectB;
        objectB.anotherObject = objectA;
    }
    ```
    在这个例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不会是0。假如这个函数被重复多次调用，就会导致大量内存得不到回收