# 数据结构

## 概论

### 基本概念和常用术语
* 数据(data) 是描述客观事务的数、字以及能**输入**计算机中并被计算机**处理**的符号的集合。
* 数据元素（data element）是数据的基本单位。
* 数据元素可由若干数据项（也称为字段、域、属性）组成，数据项是具有独立含义的最小标识单位。
* 数据对象（data object）是具有相同性质的数据元素的集合，是数据的一个子集。

#### 数据结构包含的内容

##### 数据的逻辑结构

* 线性结构： 数据元素之间存在着一对一的关系，且结构中仅有一个开始节点和一个终端节点，其余节点都是仅有一个直接前趋和一个直接后继。
* 非线性结构：数据元素之间存在着一对多或多对多的关系，即一个节点可能有多个直接前趋和多个直接后继。
  * 树结构
  * 图结构 

##### 数据的存储结构

* 顺序存储方法：把逻辑上相邻的结点存储在物理位置也相邻的连续存储单元里。
* 链接存储方法：用一组不一定连续的存储单元存储逻辑上相邻元素，元素间的逻辑关系是由附加的指针域表示的。
* 索引存储方法：存储信息的同时，还建立附加的索引表。
* 散列存储方法：根据元素的关键字，直接计算出该元素的存储地址。

> 同一种逻辑结构，采用不同的存储方法可以得到不同的存储结构。选择何种存储结构来表示相应的逻辑结构，要视具体的应用系统要求而定，而主要考虑的还是运算方便及算法的时间和空间上的要求。

##### 数据的运算

常用的有：检索，插入，删除，更新，排序等

### 算法的描述与分析

#### 算法描述

1. 输入：输入可以包含零到多个数据。
2. 输出：算法至少有一个或多个输出。
3. 有穷性：每一条指令的执行次数都是有限的，而且每一步都在又穷的时间内完成。
4. 确定性：每一条指令的含义都必须明确。
5. 可行性：算法中描述的操作都可以通过有限次的基本运算来实现。

#### 算法分析

* 时间复杂性：执行算法所耗费的时间。
  * 常数阶
  * 线性阶
  * 对数阶
  * 指数阶
* 空间复杂性：执行算法所耗费的存储空间。
* 算法应易于理解，易于编程，易于调试等，即可读性和可操作性。

## 线性表

### 线性表的逻辑定义

线性表是由 n 个数据元素组成的有限序列 (n >= 0)。其中，n 为表的长度。当 n 为零时称为空表。

对于一个非空的线性表：

* 有且仅有一个称为开始元素的 a1，它没有前趋，仅有一个直接后继 a2。
* 有且仅有一个称为终端元素的 an，它没有后继，仅有一个直接前趋 a（n-1）
* 其余元素 ai （2 <= i <= n - 1）称为内部元素，它们都有且仅有一个直接前趋 a（i - 1）和一个直接后继a（i + 1）

### 线性表的基本运算

* 置空表 `initList（L）`，构造一个空的线性表 L。
* 求表长 `listLength（L）`，返回线性表 L 中的元素个数，即表长。
* 取表中的第 i 个元素 `getNode（L, i）`
* 按值查找 `locateNode(L, x)`：在表中查找第一个值为 x 的元素
* 插入 `insertList(L, i, x)`: 在表的第 i 个元素之前插入一个值为 x 的新元素, 表的长度加1
* 删除 `deleteList(L, i)`: 删除表的第 i 个元素, 表的长度减1

以上只是线性表的基本运算, 不是全部运算, 对于更复杂的运算, 可以用基本运算的组合来实现。比如：求两个线性表中元素的并集，可以使用查找和插入操作来实现。

### 线性表的存储和基本运算的实现

#### 线性表的顺序存储

> 线性表的顺序存储指的是将线性表的数据元素按其逻辑次序一次存入一组地址连续的存储单元里, 用这种存储方式存储的线性表称为**顺序表**

假设线性表中所有元素的类型是相同的，且每个元素需占用 d 个存储单元，其中第一个单元的存储位置（地址）就是该元素的存储位置。那么，线性表中第 i+1 个元素的存储位置 LOC（a<sub>i+1</sub>）和第 i 个元素的存储位置 LOC(a)有如下关系：
**LOC(a<sub>i+1</sub>) = LOC(a) + d**
一般来说，线性表的第 i 个元素 ai 的存储位置为:
**LOC(a<sub>i</sub>）= LOC(a<sub>1</sub>) + (i-1) \* d**
其中，LOC（a<sub>1</sub>)是线性表的第一个元素a1的存储位置，通常称之为基地址。


线性表的这种机内表示称为线性表的顺序存储结构。它的特点是，元素在表中的相邻关系，在计算机内也存在着相邻的关系。每个元素 a 的存储地址是该元素在表中的位置的线性函数，只要知道基地址和每个元素占用的单元数（元素的大小），就可求出任一元素的存储地址。因此，只要确定了线性表存储的起始位置，线性表中任意一个元素都可随机存取，所以顺序表是一种随机存取结构。

#### 顺序表基本运算

* 插入

在线性表的 ` i 元素`和 `i+1 元素`之间插入一个 ` x 元素`, 需要将原表中从 ` i+1 元素`开始的元素都向后移动一个元素的位置。所以，在第 i 个元素之前插入一个元素是，需要进行 n - i + 1 次移动。

* 删除

 

#### 线性表的链式存储

##### 单链表

###### 基本运算

1. 建立单链表
   * 头插法建表
   * 尾插法建表

2. 查找运算
   * 按节点序号查找值 O(n)
   * 按值查找节点 O(n)

3. 插入
4. 删除


##### 循环链表
> 将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，因此，**从表中任意节点开始都可以访问表中其他节点**。这种头尾相接的单链表称为单循环链表，简称循环链表。

尾结点指回头结点
* 判断表空: 头结点等于尾节点
* 判断表满: 尾节点.next 等于头结点

##### 双向链表
> 单链表和循环列表的结点中只设有一个指向其后继结点的指针域, 因此, 从某个结点出发只能顺指针向后访问其他结点. 若希望从表中快速确定一个结点的直接前趋, 只要在单链表的结点类型中增加一个指向其直接前趋的指针域即可

#### 顺序表和链表的比较

线性表有两种存储结构：**顺序存储结构（顺序表）** 和 **链式存储结构（链表）**。这两种存储表示各有其特点：顺序表结构可以随机存取表中任一元素，元素的存储位置可用一个简单的公式来表示，然而在做插入和删除操作时，需要移动大量元素。而链式存储结构则可克服在做插入和删除操作时移动大量元素的问题，但却失去了随机访问的特点。那么在实际应用中，究竟选择哪种存储结构呢?这就要根据具体问题的要求和性质来决定。通常从两方面性能来比较。

1. 时间性能
   如果在实际问题中，对线性表的操作是经常性的查找运算，以顺序表形式存储为宜。因为顺序存储是一种随机存取结构，可以随机访问任一结点，访间每个结点的时间代价是一样的，即每个结点的存取时间复杂度均为 O(1)。而链式存储结构必须从表头开始沿链逐一访问各结点，其时间复杂度为 O(n)。
   如果经常进行的运算是插入和删除运算，以链式存储结构为宜。因为顺序表作插入和删除操作需要移动大量结点，而链式结构只需要修改相应的指针。

2. 空间性能
顺序表的存储空间是静态分配的，在应用程序执行之前必须给定空间大小。若线性表的长度变化较大，则其存储空间很难预先确定，设置过大将产生空间浪费，设定过小会使空间溢出，因此对数据量大小能事先知道的应用问题，适合使用顺序存储结构。而链式存储是动态分配存储空间，只要内存有空闲空间，就不会产生溢出，因此对数据量变化较大的动态问题，以链式存储结构为好。
   对于线性表结点的存储密度问题，也是选择存储结构的一个重要依据。所调存储密度就是结点空间的利用率。它的计算公式为: 
```
存储密度 =（结点数据域所占空间）/（整个结点所占空间） 
```
   一般来说，结点存储密度越大，存储空间的利用率就越高。显然，顺序表结点的存储密度是1，而链表结点的存储密度肯定小于1。例如，若单链表结点数据域为整型数，指针所占的存储空间和整型数相同，则其结点的存储密度为50%。因此，若不考虑顺序表的空闲区，则顺序表的存储空间利用率为100%，远高于单链表的结点存储密度。

## 栈和队列

### 栈

#### 栈的定义及其运算

> 栈（Stack)是限定在表的一端进行插入和删除运算的线性表，通常将插入、删除的一端称为栈顶（top)，另一端称为栈底（botom)。不含元素的空表称为空栈。
> 
> 根据上述栈的定义，每次删除（退栈）的总是当前栈中最后插入（进栈）的元素，而最先进栈的元素在栈底，要到最后才能删除。因此，栈又称为后进先出（**Last In First Out**) 的线性表，简称为 **LIFO** 表。

##### 基本运算

* 初始化
* 判栈空
* 判栈满
* 进栈 ( 压栈 )
* 退栈 ( 弹栈 )
* 取栈顶元素 (不改变栈的状态)

> 问题: 1,2,3 依次进栈, 有没有可能出现 3, 1, 2 这样的出栈顺序?

#### 栈的存储表示和实现

##### 栈的顺序存储结构

##### 栈的链式存储结构

##### 两栈共享空间

#### 栈的应用

* 括号匹配校验
* 浏览器历史记录
* 编辑器撤销

### 队列

#### 队列的定义及其运算

> 队列（Queue)也是一种操作受限的线性表，它只允许在表的一端进行元素插入，而在另一端进行元素删除。允许插入的一端称为队尾（rear)，允许删除的一端称为队头（front)。
> 
> 在队列中，通常把元素的插入称为入队，而元素的删除称为出队。队列的概念与现实生活中的排队相似，新来的成员总是加入队尾，排在队列最前面的总是最先离开队列，即先进先出，因此又称队列为先进先出（**First In First Out，FIFO**)表，简称为 **FIFO** 表。

##### 基本运算

* 初始化
* 判队空
* 判队满
* 入队
* 出队
* 取队头元素 (不改变队列状态)

#### 顺序循环队列
##### 判断队列满
```c
 (rear + 1) % QueueSize == front
```

#### 链队列

#### 队列的应用
* 键盘的输入



## 树
> 树是一种数据结构，它是由 n（n >= 1）个有限节点组成一个**具有层次关系**的集合。

* 结点所拥有的子树个数称为结点的**度**，树的度是树内各个结点的度的最大值。度为 0 的节点称为**叶子节点**或终端节点，度数不为 0 的节点称为非终端节点或分支节点。除根节点之外，分支节点也称为内部节点，根节点也称为开始节点。
* 树中某个结点子树的根称为该节点的**孩子（Child）**。相应的，该结点称为孩子结点的**双亲（Parent）或父节点**
* 若在一棵树中存在着一个结点序列，k<sub>1</sub>，k<sub>2</sub>，...，k<sub>j</sub>，使得 k<sub>i</sub> 是 k<sub>i+1</sub>的父节点，则称该结点序列是从k<sub>1</sub> 到 k<sub>j</sub> 的一条路径。从树根到树中其余结点均存在唯一的一条路径。
* 若 k<sub>i</sub> 到 k<sub>j</sub> 存在一条路径，则称节点 k<sub>i</sub>是节点 k<sub>j</sub> 的祖先，节点 k<sub>j</sub> 是 k<sub>i</sub> 的子孙。
* 树中结点的层次（Level）是从根开始算起，根为第一层，其余结点的层次等于其双亲节点的层数加 1.树中节点的最大层次称为树的**深度（Depth）或高度**。

### 树的存储结构
#### 双亲表示法
> 每个结点除了保存自身, 还保存一个指向父结点的指针, 根结点的指针域的值为 -1
优点: 可以快速找到父结点, 复杂度 O(1)
缺点: 如果想找一个结点的子结点, 需要遍历整棵树


![二叉树](http://cdn.imaxue.com/Image.png)
![二叉树数组](http://cdn.imaxue.com/Image1.png)

#### 孩子表示法
![](http://cdn.imaxue.com/Image%20%5B2%5D.png)
![](http://cdn.imaxue.com/TIM%E6%88%AA%E5%9B%BE20181202143838.png)


#### 双亲孩子表示法

![](http://cdn.imaxue.com/TIM%E6%88%AA%E5%9B%BE20181202144529.png)


#### 孩子兄弟表示法 ( 转二叉树 )
![](http://cdn.imaxue.com/TIM%E6%88%AA%E5%9B%BE20181202144700.png)
![](http://cdn.imaxue.com/TIM%E6%88%AA%E5%9B%BE20181202144839.png)

### 二叉树
> 二叉树是 n ( n >= 0 ) 个结点的有限集合

* 每个结点最多有两棵子树
* 左右子树是有顺序的

#### 满二叉树

#### 完全二叉树


#### 二叉树的存储结构
![](http://cdn.imaxue.com/TIM%E6%88%AA%E5%9B%BE20181202161935.png)
##### 顺序存储
![](http://cdn.imaxue.com/TIM%E6%88%AA%E5%9B%BE20181202162017.png)
##### 链表存储
![二叉链表](http://cdn.imaxue.com/TIM%E6%88%AA%E5%9B%BE20181202161758.png)


#### 二叉树的遍历
1. 前序遍历
根节点->左子树->右子树
![前序遍历](http://cdn.imaxue.com/20181202182500.png)
2. 中序遍历
左子树->根节点->右子树
![前序遍历](http://cdn.imaxue.com/20181202182640.png)
3. 后序遍历
左子树->右子树->根节点
![前序遍历](http://cdn.imaxue.com/20181202183055.png)

4. 层序遍历
![前序遍历](http://cdn.imaxue.com/20181202183229.png)

#### 线索二叉树

#### 哈夫曼树

![](http://cdn.imaxue.com/20181202200429.png)
![](http://cdn.imaxue.com/20181202200517.png)
![](http://cdn.imaxue.com/20181202200549.png)



## 图
### 定义
* 顶点
* 边
  * 有向边
  * 无向边

有向图
无向图
无向完全图: 任意两个顶点之间都存在边, 若有 n 个顶点, 边数 = n * ( n - 1 ) / 2


子图










