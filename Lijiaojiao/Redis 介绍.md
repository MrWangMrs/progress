## Redis 介绍

### 1.为什么使用Redis
我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。
这样，后面的请求就去缓存中读取，使得请求能够迅速响应
在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。
这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。
比如登录信息，带角色权限点的后台管理系统中，一些接口每次调用都需要带着用户信息，此时放在Redis中更合适

## 2.单线程的redis为什么快
(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制
redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。
然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中
见链接中的图，解释更清楚，原谅我不会用那个什么牛传图片。。。

## 3.redis的过期策略以及内存淘汰机制
redis采用的是定期删除+惰性删除策略(别人写的太好了，我是写不出来，抄一下吧）
> 为什么不用定时删除策略?
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。
在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.

> 定期删除+惰性删除是如何工作的呢?
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。
需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。
因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，
这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

> 采用定期删除+惰性删除就没其他问题了么?
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。
这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

https://blog.csdn.net/hjm4702192/article/details/80518856
